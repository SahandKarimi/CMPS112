
==================== FINAL INTERFACE ====================
2019-06-07 21:21:48.267331 UTC

interface hw5ty_DjY41MsUh6ZFy6M5BW9TPW:Language.Nano.Lexer 7103
  interface hash: 4609ec7d831b4c08384caf6aa95fdfae
  ABI hash: 29592f6c337de621e3a2930e3c13aa8c
  export-list hash: 89142ef6df6101cfe6c960523b0918b7
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 299fd470f67025b45b51cb4248e51215
  sig of: Nothing
  used TH splices: False
  where
exports:
  Language.Nano.Lexer.scanTokens
  Language.Nano.Lexer.Token{Language.Nano.Lexer.AND Language.Nano.Lexer.ARROW Language.Nano.Lexer.COLON Language.Nano.Lexer.COMMA Language.Nano.Lexer.ELSE Language.Nano.Lexer.EOF Language.Nano.Lexer.EQB Language.Nano.Lexer.EQL Language.Nano.Lexer.FALSE Language.Nano.Lexer.ID Language.Nano.Lexer.IF Language.Nano.Lexer.IN Language.Nano.Lexer.LAM Language.Nano.Lexer.LBRAC Language.Nano.Lexer.LEQ Language.Nano.Lexer.LESS Language.Nano.Lexer.LET Language.Nano.Lexer.LPAREN Language.Nano.Lexer.MINUS Language.Nano.Lexer.MUL Language.Nano.Lexer.NEQ Language.Nano.Lexer.NUM Language.Nano.Lexer.OR Language.Nano.Lexer.PLUS Language.Nano.Lexer.RBRAC Language.Nano.Lexer.RPAREN Language.Nano.Lexer.THEN Language.Nano.Lexer.TRUE}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 ghc-prim-0.4.0.0 integer-gmp-1.0.0.0
                      mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:GHC.Exts base-4.8.2.0:GHC.Generics
import  -/  array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA:Data.Array 6e22602c1cc5e362609f0924a7c0a209
import  -/  array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA:Data.Array.Base a0576aaf9a801948417a257cfc0c6084
import  -/  base-4.8.2.0:Data.Bits 87551525e7ef366d0fc4cad44e8b1bfc
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Arr 70f35e6bfbc61995e045edb612354887
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Exts 7bdf420b67c4b8c9ccc9ea593e90bb92
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8:Control.Monad.Error.Class 8ba4363602502bb54250b1f13f4bc60e
import  -/  mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8:Control.Monad.Except a48c40e49a1635a6f6c139e86212e5c9
import  -/  transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Except 2f5d46e037f0502f77738cc68eb8b917
addDependentFile "/Users/shawnchumbar/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/include/ghcversion.h"
addDependentFile "src/Language/Nano/Lexer.x"
addDependentFile "/Users/shawnchumbar/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/include/ghcconfig.h"
addDependentFile "/Users/shawnchumbar/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/include/ghcplatform.h"
addDependentFile "/Users/shawnchumbar/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/include/ghcautoconf.h"
addDependentFile ".stack-work/dist/x86_64-osx/Cabal-1.22.5.0/build/autogen/cabal_macros.h"
dcedfb35ce207b9f8aef89463ca55ab5
  $fEqAlexPosn :: GHC.Classes.Eq Language.Nano.Lexer.AlexPosn
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Nano.Lexer.AlexPosn
                  Language.Nano.Lexer.$fEqAlexPosn_$c==
                  Language.Nano.Lexer.$fEqAlexPosn_$c/= -}
dcedfb35ce207b9f8aef89463ca55ab5
  $fEqAlexPosn_$c/= ::
    Language.Nano.Lexer.AlexPosn
    -> Language.Nano.Lexer.AlexPosn -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: Language.Nano.Lexer.AlexPosn
                   b :: Language.Nano.Lexer.AlexPosn ->
                 case a7 of wild { Language.Nano.Lexer.AlexPn dt dt1 dt2 ->
                 case b of wild1 { Language.Nano.Lexer.AlexPn dt3 dt4 dt5 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# dt dt3) of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# dt1 dt4) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# dt2 dt5) of wild4 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } } } }) -}
dcedfb35ce207b9f8aef89463ca55ab5
  $fEqAlexPosn_$c== ::
    Language.Nano.Lexer.AlexPosn
    -> Language.Nano.Lexer.AlexPosn -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Language.Nano.Lexer.AlexPosn
                   ds1 :: Language.Nano.Lexer.AlexPosn ->
                 case ds of wild { Language.Nano.Lexer.AlexPn dt dt1 dt2 ->
                 case ds1 of wild1 { Language.Nano.Lexer.AlexPn dt3 dt4 dt5 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# dt dt3) of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# dt1 dt4) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# dt2 dt5) } } } }) -}
7a8e47bc2aec63e666b019ec690c6d57
  $fEqToken :: GHC.Classes.Eq Language.Nano.Lexer.Token
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Nano.Lexer.Token
                  Language.Nano.Lexer.$fEqToken_$c==
                  Language.Nano.Lexer.$fEqToken_$c/= -}
7a8e47bc2aec63e666b019ec690c6d57
  $fEqToken_$c/= ::
    Language.Nano.Lexer.Token
    -> Language.Nano.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: Language.Nano.Lexer.Token
                   b :: Language.Nano.Lexer.Token ->
                 case Language.Nano.Lexer.$fEqToken_$c== a7 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
7a8e47bc2aec63e666b019ec690c6d57
  $fEqToken_$c== ::
    Language.Nano.Lexer.Token
    -> Language.Nano.Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
67c5d8ff3ab3a4c24ccd42c3bf26bff6
  $fFunctorAlexLastAcc ::
    GHC.Base.Functor Language.Nano.Lexer.AlexLastAcc
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Nano.Lexer.AlexLastAcc
                  Language.Nano.Lexer.$fFunctorAlexLastAcc_$cfmap
                  Language.Nano.Lexer.$fFunctorAlexLastAcc_$c<$ -}
67c5d8ff3ab3a4c24ccd42c3bf26bff6
  $fFunctorAlexLastAcc_$c<$ ::
    a
    -> Language.Nano.Lexer.AlexLastAcc b
    -> Language.Nano.Lexer.AlexLastAcc a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a7 @ b eta :: a7 ds :: Language.Nano.Lexer.AlexLastAcc b ->
                 case ds of wild {
                   Language.Nano.Lexer.AlexNone -> Language.Nano.Lexer.AlexNone @ a7
                   Language.Nano.Lexer.AlexLastAcc x y dt
                   -> Language.Nano.Lexer.AlexLastAcc @ a7 eta y dt
                   Language.Nano.Lexer.AlexLastSkip x dt
                   -> Language.Nano.Lexer.AlexLastSkip @ a7 x dt }) -}
67c5d8ff3ab3a4c24ccd42c3bf26bff6
  $fFunctorAlexLastAcc_$cfmap ::
    (a -> b)
    -> Language.Nano.Lexer.AlexLastAcc a
    -> Language.Nano.Lexer.AlexLastAcc b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a7
                   @ b
                   ds :: a7 -> b
                   ds1 :: Language.Nano.Lexer.AlexLastAcc a7 ->
                 case ds1 of wild {
                   Language.Nano.Lexer.AlexNone -> Language.Nano.Lexer.AlexNone @ b
                   Language.Nano.Lexer.AlexLastAcc x y dt
                   -> Language.Nano.Lexer.AlexLastAcc @ b (ds x) y dt
                   Language.Nano.Lexer.AlexLastSkip x dt
                   -> Language.Nano.Lexer.AlexLastSkip @ b x dt }) -}
dcedfb35ce207b9f8aef89463ca55ab5
  $fShowAlexPosn :: GHC.Show.Show Language.Nano.Lexer.AlexPosn
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Nano.Lexer.AlexPosn
                  Language.Nano.Lexer.$fShowAlexPosn_$cshowsPrec
                  Language.Nano.Lexer.$fShowAlexPosn_$cshow
                  Language.Nano.Lexer.$fShowAlexPosn_$cshowList -}
dcedfb35ce207b9f8aef89463ca55ab5
  $fShowAlexPosn1 :: Language.Nano.Lexer.AlexPosn -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Language.Nano.Lexer.AlexPosn
                   w1 :: GHC.Base.String ->
                 case w of ww { Language.Nano.Lexer.AlexPn ww1 ww2 ww3 ->
                 Language.Nano.Lexer.$w$cshowsPrec 0 ww1 ww2 ww3 w1 }) -}
d717923caa957e972e01b1a0004345bc
  $fShowAlexPosn2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AlexPn "#) -}
dcedfb35ce207b9f8aef89463ca55ab5
  $fShowAlexPosn_$cshow ::
    Language.Nano.Lexer.AlexPosn -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Language.Nano.Lexer.AlexPosn ->
                 Language.Nano.Lexer.$fShowAlexPosn_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
dcedfb35ce207b9f8aef89463ca55ab5
  $fShowAlexPosn_$cshowList ::
    [Language.Nano.Lexer.AlexPosn] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Language.Nano.Lexer.AlexPosn
                   Language.Nano.Lexer.$fShowAlexPosn1) -}
dcedfb35ce207b9f8aef89463ca55ab5
  $fShowAlexPosn_$cshowsPrec ::
    GHC.Types.Int -> Language.Nano.Lexer.AlexPosn -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(U,U,U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Language.Nano.Lexer.AlexPosn
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Language.Nano.Lexer.AlexPn ww3 ww4 ww5 ->
                 Language.Nano.Lexer.$w$cshowsPrec ww1 ww3 ww4 ww5 w2 } }) -}
7a8e47bc2aec63e666b019ec690c6d57
  $fShowToken :: GHC.Show.Show Language.Nano.Lexer.Token
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Nano.Lexer.Token
                  Language.Nano.Lexer.$fShowToken_$cshowsPrec
                  Language.Nano.Lexer.$fShowToken_$cshow
                  Language.Nano.Lexer.$fShowToken_$cshowList -}
7a8e47bc2aec63e666b019ec690c6d57
  $fShowToken1 :: Language.Nano.Lexer.Token -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Language.Nano.Lexer.Token
                   w1 :: GHC.Base.String ->
                 Language.Nano.Lexer.$w$cshowsPrec1 0 w w1) -}
7a8e47bc2aec63e666b019ec690c6d57
  $fShowToken_$cshow :: Language.Nano.Lexer.Token -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Language.Nano.Lexer.Token ->
                 Language.Nano.Lexer.$fShowToken_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7a8e47bc2aec63e666b019ec690c6d57
  $fShowToken_$cshowList ::
    [Language.Nano.Lexer.Token] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Language.Nano.Lexer.Token
                   Language.Nano.Lexer.$fShowToken1) -}
7a8e47bc2aec63e666b019ec690c6d57
  $fShowToken_$cshowsPrec ::
    GHC.Types.Int -> Language.Nano.Lexer.Token -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Language.Nano.Lexer.Token
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Language.Nano.Lexer.$w$cshowsPrec1 ww1 w1 w2 }) -}
9f47c4341f0f871c906a415ec96a83b6
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Language.Nano.Lexer.$fShowAlexPosn2
                       (case GHC.Show.$wshowSignedInt
                               11
                               ww1
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (case GHC.Show.$wshowSignedInt
                                          11
                                          ww2
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.showSpace1
                                             (case GHC.Show.$wshowSignedInt
                                                     11
                                                     ww3
                                                     x of ww4 { (#,#) ww5 ww6 ->
                                              GHC.Types.:
                                                @ GHC.Types.Char
                                                ww5
                                                ww6 })) of ww4 { (#,#) ww5 ww6 ->
                                   GHC.Types.:
                                     @ GHC.Types.Char
                                     ww5
                                     ww6 })) of ww4 { (#,#) ww5 ww6 ->
                        GHC.Types.: @ GHC.Types.Char ww5 ww6 })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
7a8e47bc2aec63e666b019ec690c6d57
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Language.Nano.Lexer.Token -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
bcae580f76d4f839d02a62f429de934c
  $wgo ::
    Language.Nano.Lexer.AlexPosn
    -> GHC.Types.Char
    -> [Language.Nano.Lexer.Byte]
    -> GHC.Base.String
    -> Control.Monad.Trans.Except.ExceptT
         GHC.Base.String
         Data.Functor.Identity.Identity
         [Language.Nano.Lexer.Token]
  {- Arity: 4, Strictness: <L,U(U,U,U)><L,U><S,U><L,U>,
     Inline: [0] -}
e6fa310f6f1695c4229b12dfe6f61f04
  type role AlexAcc representational phantom
  data AlexAcc a user = AlexAccNone | AlexAcc a | AlexAccSkip
    Promotable
0aed47e00660b78801da7a0f5d6fb5b8
  data AlexAddr = AlexA# GHC.Prim.Addr#
ce7f7b61611dfc86f9425aef9906469a
  type AlexInput =
    (Language.Nano.Lexer.AlexPosn,
     GHC.Types.Char,
     [Language.Nano.Lexer.Byte],
     GHC.Base.String)
67c5d8ff3ab3a4c24ccd42c3bf26bff6
  data AlexLastAcc a
    = AlexNone
    | AlexLastAcc a
                  !Language.Nano.Lexer.AlexInput
                  {-# UNPACK #-}GHC.Types.Int
    | AlexLastSkip !Language.Nano.Lexer.AlexInput
                   {-# UNPACK #-}GHC.Types.Int
dcedfb35ce207b9f8aef89463ca55ab5
  data AlexPosn
    = AlexPn {-# UNPACK #-}GHC.Types.Int
             {-# UNPACK #-}GHC.Types.Int
             {-# UNPACK #-}GHC.Types.Int
982339707e0d750c92097c74f3ac1c5d
  data AlexReturn a
    = AlexEOF
    | AlexError !Language.Nano.Lexer.AlexInput
    | AlexSkip !Language.Nano.Lexer.AlexInput
               {-# UNPACK #-}GHC.Types.Int
    | AlexToken !Language.Nano.Lexer.AlexInput
                {-# UNPACK #-}GHC.Types.Int
                a
7173510f1fd5620a55b2a8fa81dc096a
  type Byte = GHC.Word.Word8
7a8e47bc2aec63e666b019ec690c6d57
  data Token
    = LET Language.Nano.Lexer.AlexPosn
    | TRUE Language.Nano.Lexer.AlexPosn
    | FALSE Language.Nano.Lexer.AlexPosn
    | IN Language.Nano.Lexer.AlexPosn
    | IF Language.Nano.Lexer.AlexPosn
    | THEN Language.Nano.Lexer.AlexPosn
    | ELSE Language.Nano.Lexer.AlexPosn
    | AND Language.Nano.Lexer.AlexPosn
    | OR Language.Nano.Lexer.AlexPosn
    | LESS Language.Nano.Lexer.AlexPosn
    | LEQ Language.Nano.Lexer.AlexPosn
    | NEQ Language.Nano.Lexer.AlexPosn
    | LAM Language.Nano.Lexer.AlexPosn
    | NUM Language.Nano.Lexer.AlexPosn GHC.Types.Int
    | ID Language.Nano.Lexer.AlexPosn GHC.Base.String
    | ARROW Language.Nano.Lexer.AlexPosn
    | EQB Language.Nano.Lexer.AlexPosn
    | EQL Language.Nano.Lexer.AlexPosn
    | PLUS Language.Nano.Lexer.AlexPosn
    | MINUS Language.Nano.Lexer.AlexPosn
    | MUL Language.Nano.Lexer.AlexPosn
    | LPAREN Language.Nano.Lexer.AlexPosn
    | RPAREN Language.Nano.Lexer.AlexPosn
    | LBRAC Language.Nano.Lexer.AlexPosn
    | RBRAC Language.Nano.Lexer.AlexPosn
    | COLON Language.Nano.Lexer.AlexPosn
    | COMMA Language.Nano.Lexer.AlexPosn
    | EOF Language.Nano.Lexer.AlexPosn
9f2f93c4ef4e96083d486cd037414f4a
  alexStartPos :: Language.Nano.Lexer.AlexPosn
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Language.Nano.Lexer.AlexPn 0 1 1) -}
99ca2bbf4fd54f0a596f2c018027eb40
  scanTokens ::
    GHC.Base.String
    -> Control.Monad.Trans.Except.Except
         GHC.Base.String [Language.Nano.Lexer.Token]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ str :: GHC.Base.String ->
                 Language.Nano.Lexer.scanTokens_go
                   (Language.Nano.Lexer.alexStartPos,
                    Language.Nano.Lexer.scanTokens1,
                    GHC.Types.[] @ Language.Nano.Lexer.Byte,
                    str)) -}
404877d0c39ce18537812e93147cddfb
  scanTokens1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '\n') -}
3949b13e245eb410fe9ad70bc3285cab
  scanTokens_go ::
    (Language.Nano.Lexer.AlexPosn,
     GHC.Types.Char,
     [Language.Nano.Lexer.Byte],
     GHC.Base.String)
    -> Control.Monad.Trans.Except.ExceptT
         GHC.Base.String
         Data.Functor.Identity.Identity
         [Language.Nano.Lexer.Token]
  {- Arity: 1, Strictness: <S(LLSL),1*U(U(U,U,U),U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: (Language.Nano.Lexer.AlexPosn,
                         GHC.Types.Char,
                         [Language.Nano.Lexer.Byte],
                         GHC.Base.String) ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 Language.Nano.Lexer.$wgo ww1 ww2 ww3 ww4 }) -}
instance GHC.Classes.Eq [Language.Nano.Lexer.AlexPosn]
  = Language.Nano.Lexer.$fEqAlexPosn
instance GHC.Classes.Eq [Language.Nano.Lexer.Token]
  = Language.Nano.Lexer.$fEqToken
instance GHC.Base.Functor [Language.Nano.Lexer.AlexLastAcc]
  = Language.Nano.Lexer.$fFunctorAlexLastAcc
instance GHC.Show.Show [Language.Nano.Lexer.AlexPosn]
  = Language.Nano.Lexer.$fShowAlexPosn
instance GHC.Show.Show [Language.Nano.Lexer.Token]
  = Language.Nano.Lexer.$fShowToken
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

